CONFIG = {
  scale: 500,
  translate: [240, 300],
  zoomContraints: [1, 3], // min & max zoom levels
  zoomChangeSpeed: 500,
  beamSpeed: 500,
  radialMenuFadeInSpeed: 200,
  radialMenuFadeOutSpeed: 200,
  layers: {},

  radialMenu: {
    delay: 100,
    speed: 100,
    initialDeg: 120,
    armWidth: 54,
    armSpeed: 250
  },

  styles: {

    // opacity
    countriesOpacity: .3,

    // parabolas
    parabolaLightStrokeWidth: 1,
    parabolaStrokeWidth: 1,

    // radius
    userRadiusWidth: 3.7,
    userStrokeWidth: 1.5,
    beamRadiusWidth: 3,
    nodeRadiusWidth: 2.7,
    nodeGlowRadiusWidth: 9,
    citiesRadiusWidth: .6,
    citiesGlowRadiusWidth: 3

  },

  sources: {
    countries: "data/countries.json",
    centroids: "data/centroids.csv"
  }
};

function VIS() {

  this.projection   = null;
  this.zoom         = null;

  this.geoPath      = null;

  this.centroids    = [];
  this.starts       = [];
  this.ends         = [];

  this.r            = 0;
  this.t            = .5;
  this.last         = 0;

  this.direction    = [];

  this.scale        = 1;
  this.currentScale = null;
  this.svg          = null;

}

/*
 * Starts timer
 */
VIS.prototype.startTimer = function() {

  var that = this;

  d3.timer(function(elapsed) {
     var d = elapsed - that.last;

    if (d > 48)  { // Peter Jackson
       that.t = that.t + (elapsed - that.last) / CONFIG.beamSpeed;
       that.last = elapsed;
       that.loop();
    }

  });
}

/*
* Map projection setup
*/
VIS.prototype.setupProjection = function() {

  this.projection = d3.geo.mercator()
  .scale(CONFIG.scale)
  .translate(CONFIG.translate);

};

/*
* Zoom setup
*/
VIS.prototype.setupZoom = function() {
  var that = this;

  this.zoom = d3.behavior.zoom()
  .scaleExtent(CONFIG.zoomContraints)
  .on("zoom", function() {
    that.redraw();
  });
}

VIS.prototype.init = function() {

  this.startTimer();

  $("#canvas").on("click", this.closeMenu);

  this.setupProjection();
  this.setupZoom();

  svg = d3.select("#canvas")
  .append("svg")
  .call(this.zoom)
  .append("g");

  this.setupFilters(svg);
  this.setupLayers();

  this.loadCountries();
};

/**
* Generates unique ids
*/
VIS.prototype.GUID = function()
{
  var S4 = function () {
    return Math.floor(
      Math.random() * 0x10000 /* 65536 */
    ).toString(16);
  };

  return (
    S4() + S4() + "-" +
      S4() + "-" +
      S4() + "-" +
      S4() + "-" +
      S4() + S4() + S4()
  );
}

/*
* Returns a hash with the coordinates of a point
*/
VIS.prototype.getCoordinates = function(coordinates) {
  return { x: coordinates[0], y: coordinates[1] };
}

/**
* Returns a random coordinate
*/
VIS.prototype.getRandomCenter = function() {
  var i = Math.round(Math.random() * (this.centroids.length - 1));
  return this.getCoordinates(this.centroids[i]);
}

/*
* Connects two points with a parabola and adds a green node
*/
VIS.prototype.connectNode = function(origin) {
  var end = this.getRandomCenter();

  this.drawParabola(origin, end, "parabola", true);
  this.addNode(end);
}

/*
* Draws n random parabolas
*/
VIS.prototype.drawParabolas = function(n) {

  var
  j    = 0
  that = this;

  _.each(that.starts.slice(0, n), function(c) {
    j++;

    var
    origin = that.getCoordinates(c),
    end    = that.getRandomCenter();

    that.drawParabola(origin, end, "parabola_light", false);

    for (i = 0; i <= Math.round(Math.random()*5); i++) {
      var randomPoint = that.getRandomCenter();
      that.drawParabola(end, randomPoint, "parabola_light", false);
      end = randomPoint;
    }

  });
}

/*
* Shows the position of the user
*/
VIS.prototype.addUser = function(center) {

  var
  layer = CONFIG.layers.nodes,
  cx    = center.x,
  cy    = center.y;

  layer
  .append("circle")
  .attr("class", "hollow")
  .attr("r", CONFIG.styles.userRadiusWidth)
  .attr('cx', cx)
  .attr('cy', cy)
}

/*
* Creates a node in the point define by *coordinates*
*/
VIS.prototype.addNode = function(coordinates) {

  var
  layer = CONFIG.layers.nodes,
  that  = this;

  var
  cx = coordinates.x,
  cy = coordinates.y;

  // Green glow
  layer.append("circle")
  .attr("class", "green_glow")
  .attr("r", CONFIG.styles.nodeGlowRadiusWidth)
  .attr('cx', cx)
  .attr('cy', cy)
  .attr("filter", "url(#blur.green)")

  // Green dot
  layer.append("circle")
  .attr("r", CONFIG.styles.nodeRadiusWidth)
  .attr("class", "dot_green")
  .attr('cx', cx)
  .attr('cy', cy)
  .attr("filter", "url(#blur.node)")
  .on("click", function() {
    d3.event.stopPropagation();

    // Coordinates of the click adjusted to the zoom
    // level & translation vector
    var
    t = that.zoom.translate(),
    x = (that.zoom.scale() * cx) + t[0],
    y = (that.zoom.scale() * cy) + t[1];

    that.openMenu(x, y);

  });
}

/*
* Closes radial menu
*/
VIS.prototype.closeMenu = function() {
  $(".radial-menu").fadeOut(CONFIG.radialMenuFadeOutSpeed, "easeOutQuad");
}

/*
* Opens radial menu
*/
VIS.prototype.openMenu = function(cx, cy) {

  var that = this;

  var $circle = $(".radial-menu");

  $circle.fadeOut(CONFIG.radialMenuFadeOutSpeed, function() {

    $(this).removeClass("zoom");

    $(this).find(".arm").remove();

    // Generates several random thumbnails
    var thumbCount = 3 + Math.round(Math.random() * 7);

    for (var i = 0; i <= thumbCount; i++) {
      var $arm = $("<div class='arm'><i></i></div>");
      $(this).append($arm);
    };

    $(".arm").css("width", 0);
    $(this).find("i").css("opacity", 0);
    $(this).css({ top: cy + 20, left: cx - 40 });

    $(this).fadeIn(CONFIG.radialMenuFadeInSpeed, "easeInQuad", function() {
      $(this).addClass("zoom");
      that.showThumbs();
    });

  });
}

/*
* Shows the radial menu thumbs
*/
VIS.prototype.showThumbs = function() {
  var
  $circle    = $(".radial-menu"),
  i          = 0,
  delay      = CONFIG.radialMenu.delay,
  speed      = CONFIG.radialMenu.speed,
  initialDeg = CONFIG.radialMenu.initialDeg,
  n = $circle.find(".arm").length;

  $circle.find(".arm").each(function(i, c) {
    i++;

    var deg = (i * 360 / n) - initialDeg;

    $(c).css("-webkit-transform", "rotate(" + deg + "deg)");
    $(c).find("i").css("-webkit-transform", "rotate(" + -1 * deg + "deg)");
    $(c).delay(i * delay).animate({ width: CONFIG.radialMenu.armWidth }, { duration: CONFIG.radialMenu.armSpeed, easing: "easeOutQuad" });

    $(c).find("i").delay(i * delay).animate({
      opacity: 1
    },
    { duration: speed, easing: "easeOutQuad" });

  });
}

/*
* Keeps the aspect of the lines & points consisten in every zoom level
*/
VIS.prototype.updateLines = function(scale) {

  svg.select("#nodes")
  .selectAll(".hollow")
  .attr("r", CONFIG.styles.userRadiusWidth/scale)
  .style("stroke-width", CONFIG.styles.userStrokeWidth/scale)

  svg.select("#beams")
  .selectAll("circle")
  .attr("r", CONFIG.styles.beamRadiusWidth/scale)

  svg.select("#cities")
  .selectAll(".dot")
  .attr("r", CONFIG.styles.citiesRadiusWidth/scale)

  svg.select("#cities_glow")
  .selectAll(".glow")
  .attr("r", CONFIG.styles.citiesGlowRadiusWidth/scale)

  svg.select("#nodes")
  .selectAll(".green_glow")
  .attr("r", CONFIG.styles.nodeGlowRadiusWidth/scale)

  svg.select("#nodes")
  .selectAll(".dot_green")
  .attr("r", CONFIG.styles.nodeRadiusWidth/scale)

  svg.select("#lines")
  .selectAll(".parabola_light")
  .attr("stroke-width", CONFIG.styles.parabolaLightStrokeWidth  / scale)

  svg.select("#lines")
  .selectAll(".parabola")
  .attr("stroke-width", CONFIG.styles.parabolaStrokeWidth / scale)
}

VIS.prototype.zoomIn = function(that) {

  var
  scale = that.zoom.scale(),
  t     = that.zoom.translate();

  if (scale > 2) return;

  that.zoom.scale(scale + 1);

  var
  x = -250 * (that.zoom.scale() - 1),
  y = -250 * (that.zoom.scale() - 1);

  that.zoom.translate([x, y]);

  svg
  .transition()
  .duration(CONFIG.zoomChangeSpeed)
  .attr("transform", "translate(" + x + "," + y + ") scale(" + that.zoom.scale() + ")");

  that.updateLines(that.zoom.scale() + .2);
}

VIS.prototype.zoomOut = function(that) {
  var
  scale = that.zoom.scale(),
  t     = that.zoom.translate();

  if (scale < 1.5) return;

  that.zoom.scale(scale - 1);

  var
  x = -250 * (that.zoom.scale() - 1),
  y = -250 * (that.zoom.scale() - 1);

  that.zoom.translate([x, y]);

  svg
  .transition()
  .duration(CONFIG.zoomChangeSpeed)
  .attr("transform", "translate(" + x + "," + y + ") scale(" + that.zoom.scale() + ")");

  that.updateLines(that.zoom.scale() + .2);
}

VIS.prototype.translateAlong = function(id, path) {
  var that = this;


  var l = path.getTotalLength();
  var precalc = [];//globalPrecal[id] = globalPrecal[id] || [];
  console.log(id);
  if(precalc.length == 0) {
    var N = 512;
    for(var i = 0; i < N; ++i) {
      var p = path.getPointAtLength((i/(N-1)) * l);
      precalc.push("translate(" + p.x + "," + p.y + ")");
    }
  }
  return function(d, i, a) {
    return function(t) {

      var p = null;

      if (that.direction[id] == 1) p = precalc[N - ((t*(N-1))>>0) - 1]; //path.getPointAtLength((1 - t) * l);
      else p = precalc[(t*(N-1))>>0];

      return p;
    };
  };
}

VIS.prototype.transition = function(circle, path) {

  var that = this;

  var id = path.attr("id");

  if (!this.direction[id]) this.direction[id] = 1;

  circle
  .transition()
  .duration(800)
  .style("opacity", .25)
  .transition()
  .duration(1500)
  .delay(Math.round(Math.random(100) * 2500))
  .style("opacity", .25)
  .attrTween("transform", this.translateAlong(id, path.node()))
  .each("end", function(t) {

    // Fade out the circle after it has stopped

    circle
    .transition()
    .duration(500)
    .style("opacity", 0)
    .each("end", function() {

      that.direction[id] = -1*that.direction[id]; // changes the direction
      that.transition(circle, path);

    });

  });
}

VIS.prototype.drawParabola = function(p1, p2, c, animated) {

  var // middle point coordinates
  x = Math.abs(p1.x + p2.x) / 2;
  y = Math.min(p2.y, p1.y) - Math.abs(p2.x - p1.x) * .3;

  var
  that   = this,
  delta  = .03,
  points = [ { x: p1.x, y: p1.y}, { x: x, y: y }, { x: p2.x, y: p2.y} ],
  line = d3.svg.line()
  .x(function(d) { return d.x; } )
  .y(function(d) { return d.y; } ),

  orders  = d3.range(3, 4);

  var path = svg
  .select("#lines")
  .data(orders)
  .selectAll("path.curve")
  .data(getCurve)
  .enter()
  .append("path")
  .attr("class", c)
  .attr("id", this.GUID())
  .attr("d", line)
  .attr("stroke-width", 1)

  function interpolate(d, p) {
    if (arguments.length < 2) p = t;
    var r = [];

    for (var i = 1; i < d.length; i++) {
      var d0 = d[i - 1],

      d1 = d[i];
      r.push({
        x: d0.x + (d1.x - d0.x) * p,
        y: d0.y + (d1.y - d0.y) * p
      });
    }
    return r;
  }

  function getLevels(d, t_) {
    if (arguments.length < 2) t_ = t;
    var x = [points.slice(0, d)];
    for (var i = 1; i < d; i++) {
      x.push(interpolate(x[x.length - 1], t_));
    }
    return x;
  }

  function getCurve(d) {
    curve = [];

    for (var t_ = 0; t_ <= 1; t_ += delta) {
      var x = getLevels(d, t_);
      curve.push(x[x.length - 1][0]);
    }

    return [curve];
  }

  if (animated) {
    var circle = svg
    .select("#beams")
    .append("circle")
    .attr("class", "beam")
    .attr("filter", "url(#blur.beam)")
    .attr("r", CONFIG.styles.beamRadiusWidth);

    that.transition(circle, path);
  }
}

/*
* This method is called every time the user
* zooms or pans.
*/
VIS.prototype.redraw = function() {

  this.closeMenu();

  scale     = d3.event.scale,
  translate = d3.event.translate;

  var t     = this.zoom.translate();

  svg
  .attr("transform", "translate(" + translate + ") scale(" + scale + ")");

  this.updateLines(scale);
}

/*
* Defines a blur effect
*/
VIS.prototype.addBlur = function(name, deviation) {
  svg
  .append("svg:defs")
  .append("svg:filter")
  .attr("id", "blur." + name)
  .append("svg:feGaussianBlur")
  .attr("stdDeviation", deviation);
}

/*
* Defines several filters
*/
VIS.prototype.setupFilters = function(svg) {
  //this.addBlur("light",   .7);
  this.addBlur("medium",  .7);
  this.addBlur("strong", 2.5);
  this.addBlur("beam",    .9);
  this.addBlur("node",    .35);
  this.addBlur("green",   1.9);
  this.addBlur("red",     0.5);
}

/*
* Main loop
*/
VIS.prototype.loop = function() {

  this.r = this.r + .1;

  // Beam animation

  var
  p       = Math.abs(Math.sin(this.t)),
  radius  = 6 + p*4/this.scale;

  svg.select("#nodes")
  .selectAll(".green_glow")
  .attr("r", radius)
  .attr("opacity", p);
}

VIS.prototype.setupLayers = function() {

  CONFIG.layers.states  = svg.append("g").attr("id", "states");
  CONFIG.layers.points  = svg.append("g").attr("id", "cities");
  CONFIG.layers.points2 = svg.append("g").attr("id", "cities_glow");
  CONFIG.layers.lines   = svg.append("g").attr("id", "lines");
  CONFIG.layers.beams   = svg.append("g").attr("id", "beams");
  CONFIG.layers.nodes   = svg.append("g").attr("id", "nodes");

}

VIS.prototype.loadCountries = function() {
  var that = this;

  d3.json(CONFIG.sources.countries, function(collection) {

    that.geoPath = d3.geo.path().projection(that.projection)

    svg.select("#states")
    .selectAll("path")
    .data(collection.features)
    .enter().append("path")
    .attr("d", that.geoPath)
    .transition()
    .duration(700)
    .style("opacity", CONFIG.styles.countriesOpacity)

    that.loadCentroids();

  });
}

VIS.prototype.loadCentroids = function() {

  var that = this;

  d3.csv(CONFIG.sources.centroids, function(collection) {

    svg.select("#cities_glow")
    .selectAll("circle")
    .data(collection)
    .enter()
    .append("circle")
    .attr("filter", "url(#blur.light)")
    .attr("class", "glow")
    .attr('cx', function(d) { return that.projection([d.LONG, d.LAT])[0]; } )
    .attr('cy', function(d) { return that.projection([d.LONG, d.LAT])[1]; } )
    .attr("r", CONFIG.styles.citiesGlowRadiusWidth);

    svg.select("#cities")
    .selectAll("circle")
    .data(collection)
    .enter()
    .append("circle")
    .attr("class", "dot")
    .attr('cx', function(d, i) {

      var p = Math.round(Math.random()*10);
      var coordinates = that.projection([d.LONG, d.LAT]);

      that.centroids.push(coordinates);

      if (p == 1) {
        that.starts.push(coordinates);
      } else if (p == 0) {
        that.ends.push(coordinates);
      }

      return coordinates[0];

    })
    .attr('cy', function(d, i) { return that.projection([d.LONG, d.LAT])[1]; })
    .attr("r", CONFIG.styles.citiesRadiusWidth);

    // Draw some random parabolas
    that.drawParabolas(3);

    // Draw the user's circle and connect it
    var center = that.getRandomCenter();

    that.addUser(center);

    for (var i = 0; i<= 2 + Math.round(Math.random() * 3); i++) {
      that.connectNode(center);
    }

  });
}

function start() {

  var vis = new VIS();

  // zoom bindings
  $(".zoom_in").on("click",  function() { vis.zoomIn(vis); });
  $(".zoom_out").on("click", function() { vis.zoomOut(vis); });

  vis.init();
}
